.. _chapter_data_staging:

************
Data Staging
************

Many, if not all, programs require input data to operate and create output
data as a result in some form or shape.
RADICAL-Pilot has a set of directives that allows the user to specify the
staging of input and output files for a Compute Unit .

RADICAL-Pilot uses system calls for local file operations and SAGA for
remote transfers and URL specification.

.. note:: Currently RADICAL-Pilot only supports data on file abstraction level,
    so `data == files` at this moment.

Staging Directives
==================

To instruct RADICAL-Pilot to handle files for you, there are two things to
take care of.
First you need to specify the respective input and output files for the
Compute Unit in so called `staging directives`.
Additionally you need to associate these `staging directives` to the the
Compute Unit by means of the ``input_staging`` and ``output_staging`` members.

What it looks like
------------------

The following code snippet shows this in action:

.. code-block:: python

    INPUT_FILE_NAME  = "INPUT_FILE.TXT"
    OUTPUT_FILE_NAME = "OUTPUT_FILE.TXT"

    # This executes: "/usr/bin/sort -o OUTPUT_FILE.TXT INPUT_FILE.TXT"
    cud = radical.pilot.ComputeUnitDescription()
    cud.executable = "/usr/bin/sort"
    cud.arguments = ["-o", OUTPUT_FILE_NAME, INPUT_FILE_NAME]
    cud.input_staging = INPUT_FILE_NAME
    cud.output_staging = OUTPUT_FILE_NAME

Here the `staging directives` ``INPUT_FILE_NAME`` and ``OUTPUT_FILE_NAME``
are simple strings that both specify a single filename and are associated to
the Compute Unit Description ``cud`` for input and output respectively.

What this does is that the file `INPUT_FILE.TXT` is transferred from the local
system to the directory where the task is executed. After the task has run,
the file `OUTPUT_FILE.TXT` that has been created by the task, will be
transferred back to the local system.

Syntax
------

The format of the `staging directives` can either be a string as above or a
dict of the following structure:

.. code-block:: python

    staging_directive = {
        'source':   source,   # radical.pilot.Url() or string (MANDATORY).
        'target':   target,   # radical.pilot.Url() or string (OPTIONAL).
        'action':   action,   # One of COPY, LINK, MOVE or TRANSFER (OPTIONAL).
        'flags':    flags,    # Zero or more of CREATE_PARENTS or SKIP_FAILED (OPTIONAL).
        'priority': priority  # A number to instruct ordering (OPTIONAL).
    }

Semantics
---------

The semantics of the keys from the dict are as follows:

- ``source`` (default: None) and ``target`` (default: os.path.basename(source)):
    In case of the `staging directive` being used for *input*,
    then the ``source`` refers to the location to get the input files
    from,  e.g. the local working directory on your laptop or a remote
    data repository, and ``target`` refers to the working directory of
    the ComputeUnit. Alternatively, in case of the `staging directive`
    being used for *output*, then the ``source`` refers to the output
    files being generated by the ComputeUnit in the working directory
    and ``target`` refers to the location where you need to store the
    output data, e.g. back to your laptop or some remote data repository.

- ``action`` (default: TRANSFER):
    The *ultimate* goal is to make data available to the application
    kernel in the ComputeUnit and to be able to make the results
    available for further use.
    Depending on the relative location of the working directory of the
    ``source`` to the ``target`` location, the action can be ``COPY``
    (local resource), ``LINK`` (same file system),
    ``MOVE`` (local resource), or ``TRANSFER`` (to a remote resource).

- ``flags`` (default: [CREATE_PARENTS, SKIP_FAILED]):
    By passing certain flags we can influence the behavior of the action.
    Available flags are:

    - ``CREATE_PARENTS``: Create parent directories while writing file.
    - ``SKIP_FAILED``: Don't stage out files if tasks failed.

    In case of multiple values these can be passed as a list.

- ``priority`` (default: 0):
    This optional field can be used to instruct the backend to priority
    the actions on the ``staging directives``. E.g. to first stage the
    output that is required for immediate further analysis and afterwards
    some output files that are of secondary concern.


When the `staging directives` are specified as a string as we did earlier,
that implies a `staging directive` where the ``source`` and the ``target``
are equal to the content of the string, the ``action`` is set to the default
action ``TRANSFER``, the ``flags`` are set to the default flags
``CREATE_PARENTS`` and ``SKIP_FAILED``, and the ``priority`` is set to the
default value ``0``:

.. code-block:: python

    'INPUT_FILE.TXT' == {
        'source':   'INPUT_FILE.TXT',
        'target':   'INPUT_FILE.TXT',
        'action':   TRANSFER,
        'flags':    [CREATE_PARENTS, SKIP_FAILED],
        'priority': 0
    }

Staging Area
------------

As the pilot job creates an abstraction for a computational resource,
the user does not know where the working directory of the Pilot or the
ComputeUnit is. Even if he/she knows, he might not have direct access to it.
For this situation we have the staging area, which is a special construct so
that the user can specify files relative to or in the working directory
without knowing the exact location. This can be done using the following
URL format:

.. code-block:: python

    'staging://INPUT_FILE.TXT'


Examples
========


String-Based Input and Output Transfer
--------------------------------------

.. literalinclude:: ../../examples/io_staging_simple.py

Dictionary-Based Input and Output Transfer
------------------------------------------

.. literalinclude:: ../../examples/io_staging_dict.py

Shared Input Files
------------------

.. literalinclude:: ../../examples/io_staging_shared.py

Pipeline
--------

.. literalinclude:: ../../examples/io_staging_pipeline.py
